defmodule Namigator.Map do
  @moduledoc """
  A Map represents a loaded navigation mesh for pathfinding.

  The map is backed by a NIF resource that manages memory automatically.
  """

  alias Namigator.NIF

  @type t :: %__MODULE__{ref: reference()}
  @type coord :: {float(), float(), float()}
  @type path :: [coord()]

  defstruct [:ref]

  @doc """
  Create a new map from the given data path and map name.

  The data path should point to a directory containing navigation mesh data
  generated by namigator's map builder.

  ## Examples

      iex> {:ok, map} = Namigator.Map.new("/path/to/nav_data", "Azeroth")

  """
  @spec new(String.t(), String.t()) :: {:ok, t()} | {:error, term()}
  def new(data_path, map_name) do
    ref = NIF.map_new(data_path, map_name)
    {:ok, %__MODULE__{ref: ref}}
  catch
    :error, reason -> {:error, reason}
  end

  @doc """
  Load all ADTs (Area Data Tiles) for the map.

  Returns the number of ADTs loaded.
  """
  @spec load_all_adts(t()) :: {:ok, integer()} | {:error, term()}
  def load_all_adts(%__MODULE__{ref: ref}) do
    count = NIF.map_load_all_adts(ref)
    {:ok, count}
  catch
    :error, reason -> {:error, reason}
  end

  @doc """
  Load a specific ADT at grid coordinates (x, y).

  Returns `true` if the ADT was loaded successfully, `false` otherwise.
  """
  @spec load_adt(t(), integer(), integer()) :: boolean()
  def load_adt(%__MODULE__{ref: ref}, x, y) do
    NIF.map_load_adt(ref, x, y)
  end

  @doc """
  Unload a specific ADT at grid coordinates (x, y).
  """
  @spec unload_adt(t(), integer(), integer()) :: :ok
  def unload_adt(%__MODULE__{ref: ref}, x, y) do
    NIF.map_unload_adt(ref, x, y)
  end

  @doc """
  Check if an ADT exists at grid coordinates (x, y).
  """
  @spec has_adt?(t(), integer(), integer()) :: boolean()
  def has_adt?(%__MODULE__{ref: ref}, x, y) do
    NIF.map_has_adt(ref, x, y)
  end

  @doc """
  Check if an ADT is currently loaded at grid coordinates (x, y).
  """
  @spec adt_loaded?(t(), integer(), integer()) :: boolean()
  def adt_loaded?(%__MODULE__{ref: ref}, x, y) do
    NIF.map_is_adt_loaded(ref, x, y)
  end

  @doc """
  Find a path between two coordinates.

  ## Options

    * `:allow_partial` - If `true`, returns a partial path when the full path
      cannot be found. Defaults to `false`.

  ## Returns

    * `{:ok, path}` - A list of coordinate tuples `{x, y, z}` representing the path
    * `{:error, :no_path}` - No path could be found between the points

  ## Examples

      iex> Namigator.Map.find_path(map, {100.0, 200.0, 50.0}, {150.0, 250.0, 55.0})
      {:ok, [{100.0, 200.0, 50.0}, {125.0, 225.0, 52.0}, {150.0, 250.0, 55.0}]}

  """
  @spec find_path(t(), coord(), coord(), keyword()) :: {:ok, path()} | {:error, :no_path}
  def find_path(%__MODULE__{ref: ref}, start, stop, opts \\ []) do
    allow_partial = Keyword.get(opts, :allow_partial, false)
    NIF.map_find_path(ref, start, stop, allow_partial)
  end

  @doc """
  Find the height (z coordinate) at position (x, y) when walking from a source point.

  This is useful when you know where the player is coming from and want to find
  the height at a nearby position they could walk to.

  ## Returns

    * `{:ok, z}` - The height at the given position
    * `{:error, :not_found}` - No valid height could be found

  """
  @spec find_height(t(), coord(), float(), float()) :: {:ok, float()} | {:error, :not_found}
  def find_height(%__MODULE__{ref: ref}, source, x, y) do
    NIF.map_find_height(ref, source, x, y)
  end

  @doc """
  Find all possible heights at position (x, y).

  This returns all z values at the given (x, y) position, useful for scenarios
  where there are multiple levels (e.g., bridges, caves).

  ## Returns

    * `{:ok, heights}` - A list of z values at the position
    * `{:error, :not_found}` - No heights could be found

  """
  @spec find_heights(t(), float(), float()) :: {:ok, [float()]} | {:error, :not_found}
  def find_heights(%__MODULE__{ref: ref}, x, y) do
    NIF.map_find_heights(ref, x, y)
  end

  @doc """
  Check if there is a clear line of sight between two points.

  ## Options

    * `:include_doodads` - If `true`, doodads (small objects) are considered
      as obstacles. Defaults to `true`.

  ## Returns

    * `true` - Clear line of sight exists
    * `false` - Something blocks the line of sight

  """
  @spec line_of_sight?(t(), coord(), coord(), keyword()) :: boolean()
  def line_of_sight?(%__MODULE__{ref: ref}, start, stop, opts \\ []) do
    include_doodads = Keyword.get(opts, :include_doodads, true)
    NIF.map_line_of_sight(ref, start, stop, include_doodads)
  end

  @doc """
  Get the zone and area IDs at a given position.

  ## Returns

    * `{:ok, {zone_id, area_id}}` - The zone and area IDs
    * `{:error, :not_found}` - Position is not on navigable terrain

  """
  @spec zone_and_area(t(), coord()) :: {:ok, {non_neg_integer(), non_neg_integer()}} | {:error, :not_found}
  def zone_and_area(%__MODULE__{ref: ref}, position) do
    NIF.map_zone_and_area(ref, position)
  end

  @doc """
  Find a random navigable point within a circle around the center.

  ## Returns

    * `{:ok, {x, y, z}}` - A random point on the navmesh within the radius
    * `{:error, :not_found}` - No valid point could be found

  """
  @spec find_random_point_around_circle(t(), coord(), float()) :: {:ok, coord()} | {:error, :not_found}
  def find_random_point_around_circle(%__MODULE__{ref: ref}, center, radius) do
    NIF.map_find_random_point_around_circle(ref, center, radius)
  end

  @doc """
  Find a point at a specific distance along the path between two points.

  ## Returns

    * `{:ok, {x, y, z}}` - A point at the specified distance from start toward end
    * `{:error, :not_found}` - Could not find a valid point

  """
  @spec find_point_in_between(t(), coord(), coord(), float()) :: {:ok, coord()} | {:error, :not_found}
  def find_point_in_between(%__MODULE__{ref: ref}, start, stop, distance) do
    NIF.map_find_point_in_between(ref, start, stop, distance)
  end
end
