defmodule Namigator.Map do
  @moduledoc """
  A Map represents a loaded navigation mesh for pathfinding.

  The map is backed by a NIF resource that manages memory automatically.
  When the Elixir struct is garbage collected, the underlying C++ resource
  is freed.

  ## Thread Safety

  **WARNING:** The underlying C++ Map class is NOT thread-safe.

  If multiple Elixir processes access the same `Namigator.Map` struct
  concurrently, you MUST serialize access (e.g., via a GenServer).

  Alternatively, each process can create its own map instance, at the
  cost of increased memory usage.

  ### Recommended Pattern

      defmodule MyApp.MapServer do
        use GenServer

        def find_path(server, start, stop) do
          GenServer.call(server, {:find_path, start, stop})
        end

        def handle_call({:find_path, start, stop}, _from, %{map: map} = state) do
          result = Namigator.Map.find_path(map, start, stop)
          {:reply, result, state}
        end
      end

  ## Coordinate System

  All coordinates use the World of Warcraft coordinate system:

  - **X-axis**: East-West (positive = East)
  - **Y-axis**: North-South (positive = North)
  - **Z-axis**: Vertical (positive = Up)

  Coordinate tuples are always `{x, y, z}` in this order.

  ## Memory Characteristics

  - Each map resource loads navigation mesh data into memory
  - ADT loading is incremental - only loaded tiles consume memory
  - `load_all_adts/1` can consume significant memory for large continents
  - Models (WMO, doodads) are reference-counted and shared across tiles
  - Resources are automatically freed when the struct is garbage collected
  """

  alias Namigator.NIF

  @type t :: %__MODULE__{ref: reference()}
  @type coord :: {float(), float(), float()}
  @type path :: [coord()]

  defstruct [:ref]

  @doc """
  Create a new map from the given data path and map name.

  The data path should point to a directory containing navigation mesh data
  generated by namigator's map builder.

  The map name must contain only alphanumeric characters, underscores, or hyphens.
  This validation prevents path traversal attacks.

  ## Examples

      iex> {:ok, map} = Namigator.Map.new("/path/to/nav_data", "Azeroth")

  ## Errors

  Returns `{:error, reason}` if:
  - The map name contains invalid characters
  - The navigation data files don't exist
  - The navigation data is corrupted
  """
  @spec new(String.t(), String.t()) :: {:ok, t()} | {:error, term()}
  def new(data_path, map_name) do
    ref = NIF.map_new(data_path, map_name)
    {:ok, %__MODULE__{ref: ref}}
  rescue
    exception -> {:error, normalize_error(exception)}
  end

  @doc """
  Load all ADTs (Area Data Tiles) for the map.

  Returns the number of ADTs loaded.

  **Note:** This can be slow and memory-intensive for large continents.
  Consider using `load_adt/3` for on-demand loading instead.
  """
  @spec load_all_adts(t()) :: {:ok, integer()} | {:error, term()}
  def load_all_adts(%__MODULE__{ref: ref}) do
    count = NIF.map_load_all_adts(ref)
    {:ok, count}
  rescue
    exception -> {:error, normalize_error(exception)}
  end

  @doc """
  Load a specific ADT at grid coordinates (x, y).

  Returns `true` if the ADT was loaded successfully, `false` otherwise.
  """
  @spec load_adt(t(), integer(), integer()) :: boolean()
  def load_adt(%__MODULE__{ref: ref}, x, y) do
    NIF.map_load_adt(ref, x, y)
  end

  @doc """
  Unload a specific ADT at grid coordinates (x, y).
  """
  @spec unload_adt(t(), integer(), integer()) :: :ok
  def unload_adt(%__MODULE__{ref: ref}, x, y) do
    NIF.map_unload_adt(ref, x, y)
  end

  @doc """
  Check if an ADT exists at grid coordinates (x, y).
  """
  @spec has_adt?(t(), integer(), integer()) :: boolean()
  def has_adt?(%__MODULE__{ref: ref}, x, y) do
    NIF.map_has_adt(ref, x, y)
  end

  @doc """
  Check if an ADT is currently loaded at grid coordinates (x, y).
  """
  @spec adt_loaded?(t(), integer(), integer()) :: boolean()
  def adt_loaded?(%__MODULE__{ref: ref}, x, y) do
    NIF.map_is_adt_loaded(ref, x, y)
  end

  @doc """
  Find a path between two coordinates.

  ## Options

    * `:allow_partial` - If `true`, returns a partial path when the full path
      cannot be found. Defaults to `false`.

  ## Returns

    * `{:ok, path}` - A list of coordinate tuples `{x, y, z}` representing the path
    * `{:error, :no_path}` - No path could be found between the points

  ## Examples

      iex> Namigator.Map.find_path(map, {100.0, 200.0, 50.0}, {150.0, 250.0, 55.0})
      {:ok, [{100.0, 200.0, 50.0}, {125.0, 225.0, 52.0}, {150.0, 250.0, 55.0}]}

  """
  @spec find_path(t(), coord(), coord(), keyword()) :: {:ok, path()} | {:error, :no_path}
  def find_path(%__MODULE__{ref: ref}, start, stop, opts \\ []) do
    allow_partial = Keyword.get(opts, :allow_partial, false)
    NIF.map_find_path(ref, start, stop, allow_partial)
  end

  @doc """
  Find the height (z coordinate) at position (x, y) when walking from a source point.

  This is useful when you know where the player is coming from and want to find
  the height at a nearby position they could walk to.

  ## Returns

    * `{:ok, z}` - The height at the given position
    * `{:error, :not_found}` - No valid height could be found

  """
  @spec find_height(t(), coord(), float(), float()) :: {:ok, float()} | {:error, :not_found}
  def find_height(%__MODULE__{ref: ref}, source, x, y) do
    NIF.map_find_height(ref, source, x, y)
  end

  @doc """
  Find all possible heights at position (x, y).

  This returns all z values at the given (x, y) position, useful for scenarios
  where there are multiple levels (e.g., bridges, caves, multi-story buildings).

  ## Returns

    * `{:ok, heights}` - A list of z values at the position
    * `{:error, :not_found}` - No heights could be found

  """
  @spec find_heights(t(), float(), float()) :: {:ok, [float()]} | {:error, :not_found}
  def find_heights(%__MODULE__{ref: ref}, x, y) do
    NIF.map_find_heights(ref, x, y)
  end

  @doc """
  Check if there is a clear line of sight between two points.

  ## Options

    * `:include_doodads` - If `true`, doodads (small objects) are considered
      as obstacles. Defaults to `true`.

  ## Returns

    * `true` - Clear line of sight exists
    * `false` - Something blocks the line of sight

  """
  @spec line_of_sight?(t(), coord(), coord(), keyword()) :: boolean()
  def line_of_sight?(%__MODULE__{ref: ref}, start, stop, opts \\ []) do
    include_doodads = Keyword.get(opts, :include_doodads, true)
    NIF.map_line_of_sight(ref, start, stop, include_doodads)
  end

  @doc """
  Get the zone and area IDs at a given position.

  ## Returns

    * `{:ok, {zone_id, area_id}}` - The zone and area IDs
    * `{:error, :not_found}` - Position is not on navigable terrain

  """
  @spec zone_and_area(t(), coord()) ::
          {:ok, {non_neg_integer(), non_neg_integer()}} | {:error, :not_found}
  def zone_and_area(%__MODULE__{ref: ref}, position) do
    NIF.map_zone_and_area(ref, position)
  end

  @doc """
  Find a random navigable point within a circle around the center.

  ## Returns

    * `{:ok, {x, y, z}}` - A random point on the navmesh within the radius
    * `{:error, :not_found}` - No valid point could be found

  """
  @spec find_random_point_around_circle(t(), coord(), float()) ::
          {:ok, coord()} | {:error, :not_found}
  def find_random_point_around_circle(%__MODULE__{ref: ref}, center, radius) do
    NIF.map_find_random_point_around_circle(ref, center, radius)
  end

  @doc """
  Find a point at a specific distance along the path between two points.

  ## Returns

    * `{:ok, {x, y, z}}` - A point at the specified distance from start toward end
    * `{:error, :not_found}` - Could not find a valid point

  """
  @spec find_point_in_between(t(), coord(), coord(), float()) ::
          {:ok, coord()} | {:error, :not_found}
  def find_point_in_between(%__MODULE__{ref: ref}, start, stop, distance) do
    NIF.map_find_point_in_between(ref, start, stop, distance)
  end

  defp normalize_error(exception) do
    message = Exception.message(exception)

    if is_binary(message) and message != "" do
      message
    else
      "unknown error"
    end
  end
end
